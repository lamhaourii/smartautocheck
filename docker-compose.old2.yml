version: '3.8'

services:
  # ============================================================================
  # INFRASTRUCTURE SERVICES - Message Broker, Databases, Cache
  # ============================================================================
  
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    container_name: smartautocheck-zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "2181"]
      interval: 10s
      timeout: 5s
      retries: 5

  kafka:
    image: confluentinc/cp-kafka:7.4.0
    container_name: smartautocheck-kafka
    depends_on:
      zookeeper:
        condition: service_healthy
    ports:
      - "9092:9092"
      - "29092:29092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
      KAFKA_LOG_RETENTION_HOURS: 168
      KAFKA_LOG_SEGMENT_BYTES: 1073741824
      # Partitioning for scalability - payments topic with 2 partitions
      KAFKA_NUM_PARTITIONS: 2
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "kafka-broker-api-versions", "--bootstrap-server", "localhost:9092"]
      interval: 10s
      timeout: 10s
      retries: 5

  # NEW: Kafka UI for visualization (Academic Requirement #6)
  # Purpose: Visual monitoring of Kafka topics, messages, consumer groups
  # Access: http://localhost:8080
  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: smartautocheck-kafka-ui
    ports:
      - "8080:8080"
    environment:
      KAFKA_CLUSTERS_0_NAME: smartautocheck
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092
      KAFKA_CLUSTERS_0_ZOOKEEPER: zookeeper:2181
    depends_on:
      - kafka
    networks:
      - smartautocheck-network

  # PostgreSQL Master - Primary database for writes
  postgres:
    image: postgres:15-alpine
    container_name: smartautocheck-postgres
    environment:
      POSTGRES_USER: smartautocheck
      POSTGRES_PASSWORD: smartautocheck_pass
      POSTGRES_DB: smartautocheck_db
      # Enable replication
      POSTGRES_INITDB_ARGS: "-c wal_level=replica -c max_wal_senders=3 -c max_replication_slots=3"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./services/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U smartautocheck -d smartautocheck_db"]
      interval: 10s
      timeout: 5s
      retries: 5

  # NEW: PostgreSQL Slave - Read replica for scaling reads (Academic Requirement #5)
  # Pattern: Database Replication for read scalability
  # Purpose: Offload read queries from master, improve query performance
  postgres-slave:
    image: postgres:15-alpine
    container_name: smartautocheck-postgres-slave
    environment:
      POSTGRES_USER: smartautocheck
      POSTGRES_PASSWORD: smartautocheck_pass
      POSTGRES_DB: smartautocheck_db
      PGUSER: smartautocheck
      POSTGRES_MASTER_HOST: postgres
      POSTGRES_MASTER_PORT: 5432
    ports:
      - "5433:5432"
    volumes:
      - postgres_slave_data:/var/lib/postgresql/data
    networks:
      - smartautocheck-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U smartautocheck"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Replica configuration will be handled by init script

  mongodb:
    image: mongo:7
    container_name: smartautocheck-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: smartautocheck
      MONGO_INITDB_ROOT_PASSWORD: smartautocheck_pass
      MONGO_INITDB_DATABASE: smartautocheck_db
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "mongosh", "--quiet", "--eval", "db.adminCommand('ping').ok", "-u", "smartautocheck", "-p", "smartautocheck_pass", "--authenticationDatabase", "admin"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: smartautocheck-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    command: redis-server --appendonly yes

  # ============================================================================
  # OBSERVABILITY & SERVICE DISCOVERY
  # ============================================================================

  # NEW: Jaeger for Distributed Tracing (Academic Requirement #1)
  # Pattern: Distributed Tracing across microservices
  # Purpose: Track requests across service boundaries, identify bottlenecks
  # Access: http://localhost:16686
  jaeger:
    image: jaegertracing/all-in-one:1.51
    container_name: smartautocheck-jaeger
    environment:
      COLLECTOR_ZIPKIN_HOST_PORT: :9411
      COLLECTOR_OTLP_ENABLED: true
    ports:
      - "5775:5775/udp"   # accept zipkin.thrift over compact thrift protocol
      - "6831:6831/udp"   # accept jaeger.thrift over compact thrift protocol
      - "6832:6832/udp"   # accept jaeger.thrift over binary thrift protocol
      - "5778:5778"       # serve configs
      - "16686:16686"     # serve frontend
      - "14250:14250"     # accept model.proto
      - "14268:14268"     # accept jaeger.thrift directly from clients
      - "14269:14269"     # admin port: health check at / and metrics at /metrics
      - "9411:9411"       # Zipkin compatible endpoint
    networks:
      - smartautocheck-network

  # NEW: Consul for Service Discovery (Academic Requirement #2)
  # Pattern: Service Registry and Discovery
  # Purpose: Dynamic service registration, health checks, service discovery
  # Access: http://localhost:8500
  consul:
    image: hashicorp/consul:latest
    container_name: smartautocheck-consul
    command: agent -server -ui -bootstrap-expect=1 -client=0.0.0.0
    ports:
      - "8500:8500"    # HTTP API and UI
      - "8600:8600/udp"  # DNS interface
    volumes:
      - consul_data:/consul/data
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "consul", "members"]
      interval: 10s
      timeout: 5s
      retries: 5

  # NEW: Nginx Load Balancer (Academic Requirement #4)
  # Pattern: Load Balancing for horizontal scaling
  # Purpose: Distribute traffic across multiple API Gateway instances
  # Routes: External traffic → Nginx → API Gateway replicas
  nginx:
    image: nginx:alpine
    container_name: smartautocheck-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./infrastructure/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./infrastructure/nginx/logs:/var/log/nginx
    depends_on:
      - api-gateway
    networks:
      - smartautocheck-network
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ============================================================================
  # CORE MICROSERVICES (7 Services)
  # ============================================================================

  # Service 1: User Service - Authentication & User Management
  user-service:
    build:
      context: ./services/user-service
      dockerfile: Dockerfile
    container_name: smartautocheck-user-service
    ports:
      - "3001:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://smartautocheck:smartautocheck_pass@postgres:5432/smartautocheck_db
      # Database replication: Use slave for reads
      DATABASE_READ_URL: postgresql://smartautocheck:smartautocheck_pass@postgres-slave:5432/smartautocheck_db
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      JWT_SECRET: ${JWT_SECRET:-your-super-secret-jwt-key}
      # Distributed Tracing
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: user-service
      # Service Discovery
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
    depends_on:
      postgres:
        condition: service_healthy
      postgres-slave:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Service 2: Appointment Service - Booking & Scheduling
  appointment-service:
    build:
      context: ./services/appointment-service
      dockerfile: Dockerfile
    # Scale this service for load testing
    # docker-compose up --scale appointment-service=3
    ports:
      - "3002:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://smartautocheck:smartautocheck_pass@postgres:5432/smartautocheck_db
      DATABASE_READ_URL: postgresql://smartautocheck:smartautocheck_pass@postgres-slave:5432/smartautocheck_db
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: appointment-service
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
    depends_on:
      postgres:
        condition: service_healthy
      postgres-slave:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      replicas: 1
      # Can be scaled: docker-compose up --scale appointment-service=3

  # Service 3: Payment Service - PayPal Integration & Invoice Generation
  # NOTE: Merged invoice-service functionality here (Academic Requirement #13)
  payment-service:
    build:
      context: ./services/payment-service
      dockerfile: Dockerfile
    ports:
      - "3003:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://smartautocheck:smartautocheck_pass@postgres:5432/smartautocheck_db
      DATABASE_READ_URL: postgresql://smartautocheck:smartautocheck_pass@postgres-slave:5432/smartautocheck_db
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      PAYPAL_CLIENT_ID: ${PAYPAL_CLIENT_ID}
      PAYPAL_CLIENT_SECRET: ${PAYPAL_CLIENT_SECRET}
      PAYPAL_MODE: ${PAYPAL_MODE:-sandbox}
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: payment-service
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
    depends_on:
      postgres:
        condition: service_healthy
      postgres-slave:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      replicas: 1
      # Can be scaled for high payment volume

  # Service 4: Inspection Service - Vehicle Inspection Workflow
  # NEW: Added WebSocket support for real-time updates (Academic Requirement #10)
  inspection-service:
    build:
      context: ./services/inspection-service
      dockerfile: Dockerfile
    container_name: smartautocheck-inspection-service
    ports:
      - "3005:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://smartautocheck:smartautocheck_pass@postgres:5432/smartautocheck_db
      DATABASE_READ_URL: postgresql://smartautocheck:smartautocheck_pass@postgres-slave:5432/smartautocheck_db
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: inspection-service
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
      # WebSocket configuration
      WEBSOCKET_ENABLED: "true"
    depends_on:
      postgres:
        condition: service_healthy
      postgres-slave:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Service 5: Certificate Service - Digital Certificate Generation
  certificate-service:
    build:
      context: ./services/certificate-service
      dockerfile: Dockerfile
    container_name: smartautocheck-certificate-service
    ports:
      - "3006:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgresql://smartautocheck:smartautocheck_pass@postgres:5432/smartautocheck_db
      DATABASE_READ_URL: postgresql://smartautocheck:smartautocheck_pass@postgres-slave:5432/smartautocheck_db
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      S3_BUCKET: smartautocheck-certificates
      S3_REGION: us-east-1
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: certificate-service
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
    depends_on:
      postgres:
        condition: service_healthy
      postgres-slave:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Service 6: Notification Service - Email & SMS Notifications
  notification-service:
    build:
      context: ./services/notification-service
      dockerfile: Dockerfile
    container_name: smartautocheck-notification-service
    ports:
      - "3009:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      MONGODB_URI: mongodb://smartautocheck:smartautocheck_pass@mongodb:27017/smartautocheck_db?authSource=admin
      REDIS_URL: redis://redis:6379
      KAFKA_BROKERS: kafka:9092
      SENDGRID_API_KEY: ${SENDGRID_API_KEY}
      TWILIO_ACCOUNT_SID: ${TWILIO_ACCOUNT_SID}
      TWILIO_AUTH_TOKEN: ${TWILIO_AUTH_TOKEN}
      TWILIO_PHONE_NUMBER: ${TWILIO_PHONE_NUMBER}
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: notification-service
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
    depends_on:
      mongodb:
        condition: service_healthy
      redis:
        condition: service_healthy
      kafka:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Service 7: API Gateway - Entry point with Circuit Breaker & Rate Limiting
  # NEW: Implements Circuit Breaker pattern, Redis-based rate limiting (Requirements #3, #7)
  api-gateway:
    build:
      context: ./services/api-gateway
      dockerfile: Dockerfile
    ports:
      - "3000-3001:3000"
    environment:
      NODE_ENV: development
      PORT: 3000
      REDIS_URL: redis://redis:6379
      # Service Discovery - Gateway discovers services via Consul
      CONSUL_HOST: consul
      CONSUL_PORT: 8500
      # Distributed Tracing
      JAEGER_AGENT_HOST: jaeger
      JAEGER_AGENT_PORT: 6831
      JAEGER_SERVICE_NAME: api-gateway
      # Circuit Breaker Configuration
      CIRCUIT_BREAKER_TIMEOUT: 10000
      CIRCUIT_BREAKER_ERROR_THRESHOLD: 50
      CIRCUIT_BREAKER_VOLUME_THRESHOLD: 10
      # Rate Limiting (distributed via Redis)
      RATE_LIMIT_WINDOW_MS: 60000
      RATE_LIMIT_MAX_REQUESTS: 100
    depends_on:
      redis:
        condition: service_healthy
      jaeger:
        condition: service_started
      consul:
        condition: service_healthy
      user-service:
        condition: service_started
      appointment-service:
        condition: service_started
      payment-service:
        condition: service_started
      inspection-service:
        condition: service_started
      certificate-service:
        condition: service_started
      notification-service:
        condition: service_started
    networks:
      - smartautocheck-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      replicas: 1
      # Scale for load balancing: docker-compose up --scale api-gateway=3

  # ============================================================================
  # FRONTEND APPLICATION
  # ============================================================================

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: smartautocheck-frontend
    ports:
      - "3010:3000"
    environment:
      # Point to Nginx load balancer instead of direct API Gateway
      NEXT_PUBLIC_API_URL: http://localhost:80
      NEXT_PUBLIC_PAYPAL_CLIENT_ID: ${PAYPAL_CLIENT_ID}
      # WebSocket for real-time updates
      NEXT_PUBLIC_WS_URL: ws://localhost:3005
    depends_on:
      - nginx
      - api-gateway
    networks:
      - smartautocheck-network
    restart: unless-stopped

# ============================================================================
# NETWORKS & VOLUMES
# ============================================================================

networks:
  smartautocheck-network:
    driver: bridge
    # Enable inter-service communication

volumes:
  postgres_data:
    driver: local
  postgres_slave_data:
    driver: local
  mongodb_data:
    driver: local
  redis_data:
    driver: local
  consul_data:
    driver: local

# ============================================================================
# DISTRIBUTED SYSTEMS PATTERNS DEMONSTRATED
# ============================================================================
# 
# 1. ✅ Distributed Tracing (Jaeger)
#    - Track requests across all 7 microservices
#    - Identify bottlenecks and latency issues
#    - Visualize service dependencies
#
# 2. ✅ Service Discovery (Consul)
#    - Dynamic service registration
#    - Health checking
#    - DNS-based service discovery
#    - No hardcoded service URLs
#
# 3. ✅ Circuit Breaker (Opossum in API Gateway)
#    - Prevent cascading failures
#    - Fallback responses
#    - Self-healing architecture
#
# 4. ✅ Load Balancing (Nginx)
#    - Horizontal scaling support
#    - Round-robin distribution
#    - Multiple gateway instances
#
# 5. ✅ Database Replication (PostgreSQL Master-Slave)
#    - Read scalability
#    - Write to master, read from replica
#    - Separate connection pools
#
# 6. ✅ Event-Driven Architecture (Kafka)
#    - Asynchronous communication
#    - Event sourcing
#    - 15+ domain events
#    - Partitioning for scalability
#
# 7. ✅ Distributed Rate Limiting (Redis)
#    - Shared rate limits across gateway instances
#    - Prevents API abuse
#    - Fair resource allocation
#
# 8. ✅ Centralized Configuration
#    - Environment-based configuration
#    - Consul for dynamic config
#
# SCALABILITY DEMONSTRATION:
# ```bash
# # Scale appointment service to 3 instances
# docker-compose up --scale appointment-service=3
# 
# # Scale API gateway to 3 instances
# docker-compose up --scale api-gateway=3
# 
# # Run load test
# k6 run load-tests/booking-flow.js
# ```
#
# MONITORING DASHBOARDS:
# - Jaeger UI: http://localhost:16686
# - Kafka UI: http://localhost:8080
# - Consul UI: http://localhost:8500
#
# ============================================================================
